<html lang="en"><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>
    Pure Rust - prma

</title>
  
  
  
    <link rel="stylesheet" href="/css/style.min.43a39cbc1ab025b429bde571624ebf83d2a20b080a2532ab78f4815a6381f344.css" integrity="sha256-Q6OcvBqwJbQpveVxYk6/g9KiCwgKJTKrePSBWmOB80Q=" crossorigin="anonymous" /> 
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"> <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"> <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"> <link rel="manifest" href="/site.webmanifest">
</head>

  <body class="m-1 mw-std">
    <article class="h-entry m-1 m-b-3">
      
	<header class="">
	  <h1 class="blocked p-name">
	    <a href="https://prma.dev/posts/pure_rust/" class="page-link simple-link u-url">Pure Rust</a>
	  </h1>
	</header>
	
	
<hr class="hr-bold-black" />

<div class="flexer">
  
<time class="dt-published">2023-03-25</time>

  <div class="tags flexer m-l-1">
      
      <div class="tag blocked m-r-1 ph1 p-category">guide</div>
      
      <div class="tag blocked m-r-1 ph1 p-category">rust</div>
      
      <div class="tag blocked m-r-1 ph1 p-category">programming</div>
      
      <div class="tag blocked m-r-1 ph1 p-category">functional-programming</div>
      
      <div class="tag blocked m-r-1 ph1 p-category">type-system</div>
      
  </div>
  <label> Auther: <a rel="author" class="p-author h-card person" href="/about/me">Perma</a></label>
</div>
<main class="e-content"><h2 id="intro">Intro</h2>
<p>If you are not familiar with Functional Programming 




















































<abbr title="Functional Programming">FP</abbr>, you are in for a ride.
I will try to explain 




















































<abbr title="Functional Programming">FP</abbr> in more practical terms.</p>
<h2 id="a-definition-to-work-with">A definition to work with</h2>
<p>




















































<abbr title="Functional Programming">FP</abbr> is a <dfn>declarative</dfn> way of writing a program that consists mostly of <em>pure functions</em> that operate on and produce <em>immutable data</em>.
That was many other unfamiliar words. Let&rsquo;s make it concrete.</p>
<h2 id="making-it-more-concrete">Making it more concrete</h2>
<p>Here is a function in 











































































































<a class="language" href="https://www.rust-lang.org/">Rust</a>




























 that we will work on:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="font-weight:bold">fn</span> <span style="color:#666;font-weight:bold;font-style:italic">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">// Calling `calculate_my_lateness` seems like magic.
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  <span style="color:#888;font-style:italic">// We don&#39;t know how it calculates it, and why it is doing that.
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  <span style="font-weight:bold;font-style:italic">let</span> <span style="font-weight:bold">mut</span> status: <span style="font-weight:bold">bool</span>;
</span></span><span style="display:flex;"><span>  calculate_my_lateness(&amp;<span style="font-weight:bold">mut</span> status);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">// This sometimes crashes and sometimes, it does not.
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  assert_eq!(status, <span style="font-weight:bold">true</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic">// The point of this function is to tell us if we are late
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic">// Ask yourself, how would you write a test for such a function?
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span><span style="font-weight:bold">fn</span> <span style="color:#666;font-weight:bold;font-style:italic">calculate_my_lateness</span>(status: <span style="font-weight:bold">&amp;</span><span style="color:#666;font-weight:bold;font-style:italic">mut</span> <span style="font-weight:bold">bool</span>) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;font-style:italic">let</span> current_time = std::time::SystemTime::now();
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;font-style:italic">let</span> expected_time = std::time::SystemTime::from(<span style="color:#666;font-weight:bold;font-style:italic">SOME_SPECIFIED_TIME</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    status = current_time &lt;= date_time;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now, let&rsquo;s make it <em>pure</em> and while we are at it, we introduce <em>pure functions</em> and some principles as well.</p>
<h3 id="pure-functions-return-at-least-one-output">Pure functions return at least one output</h3>
<p>That means that if you have a function named <code>some_function</code>, you will have at least one argument <code>some_input</code> and it will return at least one output <code>some_output</code>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="font-weight:bold">fn</span> <span style="color:#666;font-weight:bold;font-style:italic">some_function</span>(some_input) -&gt; <span style="color:#666;font-weight:bold;font-style:italic">some_output</span>
</span></span></code></pre></div><p>Why do we do this? When we are calling a function, we are expecting <span class="underline">something</span> to happen.
In 




















































<abbr title="Functional Programming">FP</abbr> world, the only acceptable <em>something</em> is an output argument.
A lack of output is <em>symptomatic</em> of one of these two unacceptable situations:</p>
<ol>
<li><strong>Our function does nothing</strong>. In which case, why are we even bothering to write it at all?</li>
<li><strong>Our function is doing a side effect</strong>. Which means that it is changing something other than what is inside the function.
These functions don&rsquo;t let us know or control what they are doing inside, without making us look at the source code.
We will get back to this throughout this post.</li>
</ol>
<p>Please note the emphasis on <em>symptomatic</em>.</p>
<p>So let&rsquo;s make it return the output:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="font-weight:bold">fn</span> <span style="color:#666;font-weight:bold;font-style:italic">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;font-style:italic">let</span> <span style="font-weight:bold">mut</span> status: <span style="font-weight:bold">bool</span>;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;font-style:italic">let</span> output = calculate_my_lateness(&amp;<span style="font-weight:bold">mut</span> status);
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">//--^^^^^^------------ we have an output now
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>
</span></span><span style="display:flex;"><span>  assert_eq!(output, <span style="font-weight:bold">true</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">//---------^^^^^^----- which we use here
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">fn</span> <span style="color:#666;font-weight:bold;font-style:italic">calculate_my_lateness</span>(status: <span style="font-weight:bold">&amp;</span><span style="color:#666;font-weight:bold;font-style:italic">mut</span> <span style="font-weight:bold">bool</span>) -&gt; <span style="font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">//-notice that we are returning something--^^^^--
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;font-style:italic">let</span> current_time = std::time::SystemTime::now();
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;font-style:italic">let</span> expected_time = std::time::SystemTime::from(<span style="color:#666;font-weight:bold;font-style:italic">SOME_SPECIFIED_TIME</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    status = current_time &lt;= date_time;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    status <span style="color:#888;font-style:italic">// &lt;- what we are returning
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>}
</span></span></code></pre></div><h3 id="pure-functions-don-t-mutate-state">Pure functions don&rsquo;t mutate state</h3>
<p>As I mentioned before, a function does something when it returns something and changes the state of something outside itself.
We call that a <dfn>side-effect</dfn>.
You may have noticed that our function takes a mutable variable of type <code>bool</code> and changes it.
In our first iteration of the function, we needed it. But now, we grew out of it. So let&rsquo;s just delete it.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="font-weight:bold">fn</span> <span style="color:#666;font-weight:bold;font-style:italic">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">// let mut status: bool;  &lt;- we don&#39;t need this
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;font-style:italic">let</span> output = calculate_my_lateness();
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">//--------------------------------^ we don&#39;t need to take status any more
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>
</span></span><span style="display:flex;"><span>  assert_eq!(output, <span style="font-weight:bold">true</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">fn</span> <span style="color:#666;font-weight:bold;font-style:italic">calculate_my_lateness</span>() -&gt; <span style="font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">//------------------^^- we don&#39;t need to take a mutable variable
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;font-style:italic">let</span> current_time = std::time::SystemTime::now();
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;font-style:italic">let</span> expected_time = std::time::SystemTime::from(<span style="color:#666;font-weight:bold;font-style:italic">SOME_SPECIFIED_TIME</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    current_time &lt;= date_time <span style="color:#888;font-style:italic">//  &lt;- what we are returning
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>}
</span></span></code></pre></div><p>Now isn&rsquo;t this better? When I call <code>calculate_my_lateness()</code>
I&rsquo;m not worried about the function changing anything it&rsquo;s not supposed to anymore.
Let&rsquo;s move on.</p>
<h3 id="pure-functions-return-output-only-based-on-their-argument">Pure functions return output only based on their argument</h3>
<p>Which means that when I call <code>calculate_my_lateness()</code>, I should not expect it to do something different each time I run it.
Why is that? There are two reasons:</p>
<ol>
<li><strong>Transparency</strong>: You should know what parameters change the output of a function, without needing to reading the function body.</li>
<li><strong>Testing</strong>: It is hell of a lot easier to test a function that you can just control without needing to change the time of your computer. Won&rsquo;t you say?</li>
</ol>
<p>Let&rsquo;s do it in two steps this time.</p>
<h4 id="step-one-don-t-use-global-variables">Step one: Don&rsquo;t use global variables</h4>
<p>you may have noticed <code>SOME_SPECIFIED_TIME</code>.
This is a variable we use to make a <code>SystemTime</code> which we compare current time with to know if we are late or not.
The problem here is these two:</p>
<ol>
<li>We need to write a new function, each time we have a new meeting.</li>
<li>We also don&rsquo;t know what time current time is being compared to, unless we first read the function, and then find out what it uses as <code>SOME_SPECIFIED_TIME</code>.</li>
</ol>
<!--listend-->
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="font-weight:bold">fn</span> <span style="color:#666;font-weight:bold;font-style:italic">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;font-style:italic">let</span> output = calculate_my_lateness(SystemTime::from(<span style="color:#666;font-weight:bold;font-style:italic">SOME_SPECIFIED_TIME</span>));
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">//---------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  <span style="color:#888;font-style:italic">// now the caller is supposed to provide the time
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>
</span></span><span style="display:flex;"><span>  assert_eq!(output, <span style="font-weight:bold">true</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">fn</span> <span style="color:#666;font-weight:bold;font-style:italic">calculate_my_lateness</span>(late_as_of: <span style="color:#666;font-weight:bold;font-style:italic">SystemTime</span>) -&gt; <span style="font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">//-------------------^^^^^^^^^^^^^^^^^^^^^^-----------
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;font-style:italic">let</span> current_time = std::time::SystemTime::now();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    current_time &lt;= late_as_of
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="step-two-don-t-use-functions-with-side-effects-inside-your-function">Step Two: don&rsquo;t use functions with side effects inside your function</h4>
<p>Imagine that you have a non-alcoholic drink, if you add another non-alcoholic drink to it, it is still non-alcoholic.
But if you add an alcoholic drink to it, it will not remain non-alcoholic anymore.
A pure function is only pure, if all the functions that are being called in it, are pure.
And <code>std::time:SystemTime::now()</code> is definitely not pure.
Now, at some point we need to get the current time, but we don&rsquo;t need to do that where it is hidden from the caller.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="font-weight:bold">fn</span> <span style="color:#666;font-weight:bold;font-style:italic">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;font-style:italic">let</span> output = calculate_my_lateness(
</span></span><span style="display:flex;"><span>                   SystemTime::from(<span style="color:#666;font-weight:bold;font-style:italic">SOME_SPECIFIED_TIME</span>),
</span></span><span style="display:flex;"><span>                   SystemTime::now(),<span style="color:#888;font-style:italic">//&lt;------ we provide the time
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  assert_eq!(output, <span style="font-weight:bold">true</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">fn</span> <span style="color:#666;font-weight:bold;font-style:italic">calculate_my_lateness</span>(late_as_of: <span style="color:#666;font-weight:bold;font-style:italic">SystemTime</span>, target_time: <span style="color:#666;font-weight:bold;font-style:italic">SystemTime</span> ) -&gt; <span style="font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">//-------------------------------------------^^^^^^^^^^^^^^^^^^^^^^^-----------
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    target_time &lt;= late_as_of
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now the nice thing here is that we can easily test this function now!</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#888;font-style:italic">// main and calculate_my_lateness are not shown here. Don&#39;t be alarmed.
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#888;font-weight:bold">#[cfg(test)]</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">mod</span> <span style="color:#666;font-weight:bold;font-style:italic">tests</span> {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">use</span> <span style="font-weight:bold">super</span>::calculate_my_lateness;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">use</span> std::time::SystemTime;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-weight:bold">#[test]</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">fn</span> <span style="color:#666;font-weight:bold;font-style:italic">being_late_works</span>() {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;font-style:italic">let</span> res = calculate_my_lateness(
</span></span><span style="display:flex;"><span>            SystemTime::from(<span style="color:#666;font-weight:bold;font-style:italic">A_TIME</span>),
</span></span><span style="display:flex;"><span>            SystemTime::from(<span style="color:#666;font-weight:bold;font-style:italic">A_TIME_THAT_IS_AFTER_LATE_TIME</span>),
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>        assert_eq!(res, <span style="font-weight:bold">true</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-weight:bold">#[test]</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">fn</span> <span style="color:#666;font-weight:bold;font-style:italic">being_early_works</span>() {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;font-style:italic">let</span> res = calculate_my_lateness(
</span></span><span style="display:flex;"><span>            SystemTime::from(<span style="color:#666;font-weight:bold;font-style:italic">A_TIME</span>),
</span></span><span style="display:flex;"><span>            SystemTime::from(<span style="color:#666;font-weight:bold;font-style:italic">A_TIME_THAT_IS_BEFORE_LATE_TIME</span>),
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>        assert_eq!(res, <span style="font-weight:bold">false</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Imagine doing this with the first function!</p>
<h4 id="one-more-step">One more step</h4>
<p>OK, I lied&hellip; Somewhat. Have you noticed the one glaring, lack of transparency and control here?
It&rsquo;s the <code>&lt;=</code>. You may need to read the function here, if you have this simple question:</p>
<blockquote>
<p>If I call the function exactly, at the precise moment that I specified to be <code>late_as_of</code>, will return true, or false?</p>
</blockquote>
<p>Now, not answering this question using the function signature,won&rsquo;t make my function less pure,but still, it is a much nicer experience for the caller to be able to rely on their IDE&rsquo;s autocomplete to tell them what happens.But how the hell should we do that? Easy! We take a comparator function as input!</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="font-weight:bold">fn</span> <span style="color:#666;font-weight:bold;font-style:italic">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;font-style:italic">let</span> output = calculate_my_lateness(
</span></span><span style="display:flex;"><span>                   SystemTime::from(<span style="color:#666;font-weight:bold;font-style:italic">SOME_SPECIFIED_TIME</span>),
</span></span><span style="display:flex;"><span>                   SystemTime::now(),
</span></span><span style="display:flex;"><span>                   |late, target| target &gt; late, <span style="color:#888;font-style:italic">// here the caller passes the function
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>                                                 <span style="color:#888;font-style:italic">// you can also provide a few different functions yourself to make it easier for the caller
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  assert_eq!(output, <span style="font-weight:bold">true</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">fn</span> <span style="color:#666;font-weight:bold;font-style:italic">calculate_my_lateness</span>(
</span></span><span style="display:flex;"><span>    late_as_of: <span style="color:#666;font-weight:bold;font-style:italic">SystemTime</span>,
</span></span><span style="display:flex;"><span>    target_time: <span style="color:#666;font-weight:bold;font-style:italic">SystemTime</span>,
</span></span><span style="display:flex;"><span>    comparer: <span style="color:#666;font-weight:bold;font-style:italic">fn</span>(SystemTime, SystemTime) -&gt; <span style="font-weight:bold">bool</span>, <span style="color:#888;font-style:italic">// magic happens here
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>) -&gt; <span style="font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    comparer(late_as_of, target_time)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now the caller is providing us we have everything we need. We did not hide one single thing.</p>
<h3 id="isn-t-this-just-more-work-for-caller">Isn&rsquo;t this just more work for caller?</h3>
<p>Well, yes. Yes, it is&hellip; if calling functions without understanding them is the only work that the caller of our function is doing.
Otherwise, our caller knows everything they need using their language server, can change everything they need, have the assurance of our tests and don&rsquo;t need to crawl through our source code, and they will face much fewer bugs where they don&rsquo;t know where it came from.
It may seem unnecessary for this simple function, but imagine much more complex functions.</p>
<h2 id="making-things-nicer-a-spicy-problem">Making things nicer: A spicy problem</h2>
<p>So we have all this power and transparency.
But the elephant is in it room: We have a very shitty 




















































<abbr title="Application Programming Interface">API</abbr>.
Let&rsquo;s make it nicer using a technique called <dfn>currying</dfn> (hence the &ldquo;spicy&rdquo; pun).
What it means is: as well as taking functions as argument, we can return functions.
That way, our <code>calculate_my_lateness</code> function can become a function-maker.
Let me make it more concrete.</p>
<h3 id="consider-the-use-case">Consider the use case</h3>
<p>Let us suppose that we want to find time in our list of times that is not late.
Currently, we have to call the whole function, repeatedly, and include every argument.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#888;font-style:italic">// we are in main, don&#39;t be alarmed
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span><span style="font-weight:bold;font-style:italic">let</span> output_time1 = calculate_my_lateness(
</span></span><span style="display:flex;"><span>    SystemTime::from(<span style="color:#666;font-weight:bold;font-style:italic">SOME_SPECIFIED_TIME</span>),
</span></span><span style="display:flex;"><span>    SystemTime::from(<span style="color:#666;font-weight:bold;font-style:italic">FIRST_TIME</span>), <span style="color:#888;font-style:italic">//&lt;------ we provide the time
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    |late, target| target &gt; late,
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;font-style:italic">let</span> output_time2 = calculate_my_lateness(
</span></span><span style="display:flex;"><span>    SystemTime::from(<span style="color:#666;font-weight:bold;font-style:italic">SOME_SPECIFIED_TIME</span>),
</span></span><span style="display:flex;"><span>    SystemTime::from(<span style="color:#666;font-weight:bold;font-style:italic">SECOND_TIME</span>), <span style="color:#888;font-style:italic">//&lt;------ we provide the time
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    |late, target| target &gt; late,
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;font-style:italic">let</span> output_time3 = calculate_my_lateness(
</span></span><span style="display:flex;"><span>    SystemTime::from(<span style="color:#666;font-weight:bold;font-style:italic">SOME_SPECIFIED_TIME</span>),
</span></span><span style="display:flex;"><span>    SystemTime::from(<span style="color:#666;font-weight:bold;font-style:italic">THIRD_TIME</span>), <span style="color:#888;font-style:italic">//&lt;------ we provide the time
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    |late, target| target &gt; late,
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic">// etc...
</span></span></span></code></pre></div><p>This is not great.
Here, We can just make a function that only takes our target time.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="font-weight:bold">fn</span> <span style="color:#666;font-weight:bold;font-style:italic">calculate_my_lateness</span>(
</span></span><span style="display:flex;"><span>    late_as_of: <span style="color:#666;font-weight:bold;font-style:italic">SystemTime</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">// target_time: SystemTime &lt;------------ we don&#39;t need to take this argument anymore
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    comparer: <span style="color:#666;font-weight:bold;font-style:italic">fn</span>(late_as_of: <span style="color:#666;font-weight:bold;font-style:italic">SystemTime</span>, target_time: <span style="color:#666;font-weight:bold;font-style:italic">SystemTime</span>) -&gt; <span style="font-weight:bold">bool</span>,
</span></span><span style="display:flex;"><span>) -&gt; <span style="color:#666;font-weight:bold;font-style:italic">fn</span>(target_time: <span style="color:#666;font-weight:bold;font-style:italic">SystemTime</span>) -&gt; <span style="font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#888;font-style:italic">//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---- notice that we are now returning a function
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    |target_time: <span style="color:#666;font-weight:bold;font-style:italic">SystemTime</span>| -&gt; <span style="font-weight:bold">bool</span> { comparer(target_time, late_as_of) }
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">//^^^^^^^^^^^^^^^^^^^^^^           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="color:#888;font-style:italic">//         |                this is where the calculation of lateness happens
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="color:#888;font-style:italic">// we are taking target time here
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span> }
</span></span></code></pre></div><p>You might ask, &ldquo;well, how does this help?&rdquo;</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#888;font-style:italic">// we are in  main
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic">// now our late_before_time_x is not of type bool,
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic">// rather it is of type Fn(SystemTime) -&gt; bool
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span><span style="font-weight:bold;font-style:italic">let</span> late_before_time_x = calculate_my_lateness(
</span></span><span style="display:flex;"><span>    SystemTime::from(<span style="color:#666;font-weight:bold;font-style:italic">SOME_SPECIFIED_TIME</span>),
</span></span><span style="display:flex;"><span>    |late, target| target &gt; late,
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic">// So we can just:
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span><span style="font-weight:bold;font-style:italic">let</span> first_result = late_before_time_x(<span style="color:#666;font-weight:bold;font-style:italic">FIRST_TIME</span>);
</span></span><span style="display:flex;"><span><span style="font-weight:bold;font-style:italic">let</span> second_result = late_before_time_x(<span style="color:#666;font-weight:bold;font-style:italic">SECOND_TIME</span>);
</span></span><span style="display:flex;"><span><span style="font-weight:bold;font-style:italic">let</span> third_result = late_before_time_x(<span style="color:#666;font-weight:bold;font-style:italic">THIRD_TIME</span>);
</span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic">// ...much less boilerplate
</span></span></span></code></pre></div><h3 id="why-const-just-won-t-do">Why <code>const</code> just won&rsquo;t do</h3>
<p>Veteran rustaceans among the readers of this blog might ask: &ldquo;why not just use <code>const</code> to mark that functions are pure?&rdquo;
Well dear veteran, if you can make a function <code>const</code>, do every one a favor and actually do it.
In fact, I regularly use <code>clippy::missing_const_for_fn</code> lint and suggest you to use it as well.
But that does not guarantee that our functions are pure, or that every pure function can be <code>const</code>.
Here are my reasons:</p>
<ol>
<li><code>const</code> functions can take <code>&amp;mut something</code> as their arguments. Taking mutable references is definitely not very pure-function-y.</li>
<li>You cannot <code>const</code> trait methods in stable 











































































































<a class="language" href="https://www.rust-lang.org/">Rust</a>




























, as of now. And considering that every function call inside a <code>const</code> function should be <code>const</code> as well, you are extremely limited, without any reasons that have to do with pure functions.</li>
<li>Many libraries don&rsquo;t to use <code>const</code> on the functions that are <code>const</code>. Again, limitation without pureness reasons.</li>
</ol>
<h2 id="making-things-declarative">Making things declarative</h2>
<p>There is this often repeated old joke that says:</p>
<blockquote>
<p>There two hard problems in programming</p>
<ol>
<li>Cache invalidation</li>
<li>Naming things</li>
</ol>
<p>&ndash; <span class="person p-name">Phil Karlton</span></p>
</blockquote>
<p>And here we are concerned with the second one.</p>
<ul>
<li>In the <strong>imperative</strong> universe, we usually name our functions using <em>verbs</em>. Think <code>calculate_my_lateness</code>.</li>
<li>In the <strong>declarative</strong> universe we are concerned with our output, we use <em>nouns</em>. Think <code>lateness_calculator</code>.</li>
</ul>
<p>This makes the intent of our function clear.
How it is implemented under-the-hood is not what matters to the caller.
They only care about what they get out of it.
If you now are thinking that you cared about that part before, consider the things that we just can answer by seeing the arguments that our function takes.
We don&rsquo;t need to rely on our function name anymore to tell use how the function is calculating lateness.
We only need to know what it&rsquo;s intention is.</p>
<h2 id="dear-reader">Dear Reader</h2>
<p>In this post, I just preferred to focus on the heart of 




















































<abbr title="Functional Programming">FP</abbr>: <em>pure declarative functions</em>.
However, functional programming brings with it a set of extremely useful tools, patterns, etc. most well known are <em>iterators</em>, <em>maps</em>, <em>folds</em>, <em>filters</em>, etc.
Honestly, they are well explained in other resources. My only suggestion would be to check out <a href="https://docs.rs/itertools/latest/itertools/">itertools</a> crate.</p>
</main>
<aside> <p>Comment section? I Have none! But I like emails: <a class="u-email" href="mailto:prma.dev@protonmail.com">prma.dev@protonmail.com</a></p></aside>

    </article>
     <footer class="m-1">
  <div class="blocked centered">
    <h1 class="site-title blocked p-1">
      <a href="/" class="ntdl site-link">prma</a>
    </h1>
  </div>

  <details class ="centered m-1">
    <summary> Find me </summary>
    <div class="blocked flexer item-align-center fl-row-wrap gap-c-1 gap-r-1">
	<a href="https://fosstodon.org/@prma"  rel ="me"  class="blocked .w-20  fl-basis-40  p-1 centered  fl-grow-1 b-black b-0-2 fg-black"> Fosstodon</a>

	<a href="https://codeberg.org/prma"  rel ="me"  class="blocked .w-20  fl-basis-40  p-1 centered  fl-grow-1 b-black b-0-2 fg-black"> Codeberg</a>

	<a href="https://linkedin.com/in/prmadev"  rel ="me"  class="blocked .w-20  fl-basis-40  p-1 centered  fl-grow-1 b-black b-0-2 fg-black"> Linkedin</a>

    </div>
  </details>

  <details class ="centered m-1" >
    <summary> About </summary>
    <div class="h-card p-auther">
      <p>I'm <a class="p-name p-nickname p-author u-url" rel="auther" href="/about/me">Perma</a>. </p>
      <div class="blocked flexer item-align-center fl-row-wrap gap-c-1 gap-r-1">
	<a href="/about/me"  class="blocked .w-20  fl-basis-40  p-1 centered  fl-grow-1 b-black b-0-2 fg-black"> Me</a>

    </div>
    </div>
  </details>

  <details class ="centered m-1" >
    <summary> Feed </summary>
    <div class="blocked flexer item-align-center fl-row-wrap gap-c-1 gap-r-1">
	<a href="/index.xml"  class="blocked .w-20  fl-basis-40  p-1 centered  fl-grow-1 b-black b-0-2 fg-black"> Atom</a>

	<a href="/feed.json"  class="blocked .w-20  fl-basis-40  p-1 centered  fl-grow-1 b-black b-0-2 fg-black"> JsonFeed</a>

    </div>
  </details>
</footer>
 
  </body>
</html>
