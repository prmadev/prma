<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content=text/html http-equiv=Content-Type><meta content="width=device-width,initial-scale=1" name=viewport><title>19% of Rustaceans Need To Know This!</title><meta content="19% of Rustaceans Need To Know This!" name=title><meta content="The act of moving arguments within Rust's functions serves as a compelling means to uphold the purity of the function. By embracing this practice, we …" name=description><meta content="Zola v0.16.1" name=generator><meta content=website property=og:type><meta content=https://prma.dev/moving_is_pure/ property=og:url><meta content=prma property=og:site_name><meta content="19% of Rustaceans Need To Know This!" property=og:title><meta content="The act of moving arguments within Rust's functions serves as a compelling means to uphold the purity of the function. By embracing this practice, we …" property=og:description><meta content=https://prma.dev/img/avatar.png property=og:image><link href=https://prma.dev/moving_is_pure/ rel=canonical><link rel="shortcut icon" href=https://prma.dev/img/avatar.png type=image/x-icon><script type=application/ld+json>
            {
                "description":"The act of moving arguments within Rust's functions serves as a compelling means to uphold the purity of the function. By embracing this practice, we …",
                "url":"https://prma.dev/moving_is_pure/",
                "@type":"WebSite",
                "headline":"19% of Rustaceans Need To Know This!",
                "name":"19% of Rustaceans Need To Know This!",
                
                "@context":"https://schema.org"
            }
        </script><link href=https://prma.dev/atom.xml rel=alternate title=RSS type=application/atom+xml><link href=https://prma.dev/style.css rel=stylesheet><body><div class=w><header><nav><a href=" /">prma</a><a href=" /tags"># tags</a><a href=" /categories">+ categories</a><a href=" /about/me">> about/me</a><a href=" /about/prma">> about/prma</a><a href=" /atom.xml">= feed</a></nav><div class=top-info><p class=breadcrums><a href=..>..</a>/moving_is_pure<p class=post-meta><time datetime=2023-04-09>2023-04-09</time></div><h1>19% of Rustaceans Need To Know This!</h1><div class=page-post-description><p>The act of moving arguments within Rust's functions serves as a compelling means to uphold the purity of the function. By embracing this practice, we ensure that the function operates on unique ownership of its inputs, preserving the integrity and immutability of data, which are fundamental tenets of functional programming.</div></header><main aria-label=Content class=page-content><section class=intro><p>Or you can also read the title as: I made a poll and 81% agreed with me. So you probably don't need to read on. I know, I hate the title as well. But I couldn't resist. So here is another, better title:</section><h2 id="Moving_a_Variable_to_a_Function_in_Rust_Doesn't_Make_It_Impure">Moving a Variable to a Function in Rust Doesn't Make It Impure</h2><p>So as an introduction, if you don't know Rust: In Rust, we have this concept of moving variables. It is like this:<pre class=language-rust data-lang=rust style=background:#fff;color:#202020><code class=language-rust data-lang=rust><span style=color:#bbb>//  A variable is made. 
</span><span>let a_variable = some_value; 
</span><span>
</span><span style=color:#bbb>// It moves into this function.
</span><span>_ = a_function_that_takes_ownership(a_variable);
</span><span>
</span><span style=color:#bbb>// We cannot use a_variable anymore! So, we cannot do this!
</span><span>let b_variable = a_variable; 
</span><span>  
</span></code></pre><p>Now I consider <code>a_function_that_takes_ownership</code> to be a pure function. However, it raises a possible confusion:<blockquote><p>Doesn't <code>a_function_that_takes_ownership</code> change the state of the outer function? Isn't that a side effect?</blockquote><p>I argue that it doesn't. Here is why: a function is not a function call. Ok. let's visualize it.<pre style=background:#fff;color:#202020><code><span>      ________outer_function_______
</span><span>--in->|       __inner_f___        |-out->
</span><span>      | -in-> |          | -out-> |
</span><span>      |       ------------        |
</span><span>      -----------------------------
</span></code></pre><p>So we have two functions. One outer, and one inner.<ul><li>Each function should have inputs and an output.<li>Other than their outputs, they should not change anything outside their function space.</ul><p>If these conditions are not met, our function is not pure.<p><strong>Step 1.</strong> Now consider a variable <code>[V]</code>.<pre style=background:#fff;color:#202020><code><span>      _____________________________
</span><span>----->| [v]   ____________        |----->
</span><span>      | ----> |          | -----> |
</span><span>      |       ------------        |
</span><span>      -----------------------------
</span></code></pre><p><strong>Step 2.</strong> With our outer function, we create a function call for the inner function.<pre style=background:#fff;color:#202020><code><span>      _____________________________
</span><span>----->|       ____________        |----->
</span><span>      | [v]-> |          | -----> |
</span><span>      |       ------------        |
</span><span>      -----------------------------
</span></code></pre><p><strong>Step 3.</strong> It is no longer in the state space of the outer function. The inner function takes ownership of it.<pre style=background:#fff;color:#202020><code><span>      _____________________________
</span><span>----->|       ____________        |----->
</span><span>      | ----> |   [v]    | -----> |
</span><span>      |       ------------        |
</span><span>      -----------------------------
</span></code></pre><p>Semantically, for the outer function <code>[v]</code> was used in the function call and then dropped. Which does not violate our rules. For the inner function, it just got an input and returns an output. So it makes sematic sense. In practice, it also makes the same guarantees as any other pure function:<ul><li>No null pointers.<li>No mutable state.<li>No side effects.</ul><p>If the caller <code>.clone()</code> our value and make a copy of it and pass that to the inner function, it provides us with no other guarantees, other than more memory usage and slightly longer code.<h2 id=Why_does_it_matter?>Why does it matter?</h2><p>Well, Honestly, it doesn't. I just had to decide if in a pure function I can consume a <code>self</code>, if I want to make it a pure function, considering that I cannot make it <code>const</code>.<br> This was my thinking output. Now you are the outer function.<aside class=discussion-info>Comment section? I have none. But feel free to email me at: <a class=email-box href=mailto:prma.dev@protonmail.com>prma.dev@protonmail.com</a></aside></main><footer><p class=taxonomies><a href=/tags/programming>#programming</a> <a href=/tags/rust>#rust</a> <a href=/tags/functional-programming>#functional-programming</a> <a href=/categories/opinion>+opinion</a></footer></div>