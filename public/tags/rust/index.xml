<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rust on prma</title>
    <link>https://prma.dev/tags/rust/</link>
    <description>Recent content in rust on prma</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>prma.dev@protonmail.com (Perma)</managingEditor>
    <webMaster>prma.dev@protonmail.com (Perma)</webMaster>
    <copyright>CC v.4</copyright>
    <lastBuildDate>Mon, 16 Oct 2023 23:04:00 +0330</lastBuildDate>
    <atom:link href="https://prma.dev/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Rust Skills Transferability</title>
      <link>https://prma.dev/daily/rust-skills-transferability/</link>
      <pubDate>Mon, 16 Oct 2023 23:04:00 +0330</pubDate><author>prma.dev@protonmail.com (Perma)</author>
      <guid>https://prma.dev/daily/rust-skills-transferability/</guid>
      <description>While the skills learned in Rust , like working with the borrow checker, may seem limited to Rust itself, the claim of their intransferability is somewhat overstated. Understanding the borrow checker is specific to languages using it, but the approaches it encourages are typically advanced and valued by experienced engineers. And often, it is evidenced by the patterns that are simplest to implement. The obvious exception to that is unwrap() and expect().</description>
    </item>
    <item>
      <title>Rust&#39;s Productivity</title>
      <link>https://prma.dev/daily/rust-productivity/</link>
      <pubDate>Mon, 16 Oct 2023 23:04:00 +0330</pubDate><author>prma.dev@protonmail.com (Perma)</author>
      <guid>https://prma.dev/daily/rust-productivity/</guid>
      <description>I think the best way to characterize Rust &amp;rsquo;s productivity, is to put it on a quality axis.
If you want low quality code (prototyping, etc) rust is much less productive than the alternative.
For medium level of quality, Rust is similar to others.
For high quality code, Rust is much more productive than any alternatives.
Quality is intentionally vague, to encapsulate performance, leanness, documentation, and security.</description>
    </item>
    <item>
      <title>Missing Rust Blogpost</title>
      <link>https://prma.dev/daily/missing-rust-post/</link>
      <pubDate>Mon, 16 Oct 2023 18:57:00 +0330</pubDate><author>prma.dev@protonmail.com (Perma)</author>
      <guid>https://prma.dev/daily/missing-rust-post/</guid>
      <description>There is a blog post missing in the Rust sphere: How to not obssess over performance gain and improve changeability of Rust applications.
In other words, imagin that you want move a function used in one file to another. How would you do that in under ten minutes?</description>
    </item>
    <item>
      <title>Go Vs Rust readability</title>
      <link>https://prma.dev/posts/go_vs_rust_readability/</link>
      <pubDate>Fri, 14 Apr 2023 23:49:00 +0330</pubDate><author>prma.dev@protonmail.com (Perma)</author>
      <guid>https://prma.dev/posts/go_vs_rust_readability/</guid>
      <description>Intro Traditionally speaking, Go and Rust are not direct competitors on many fronts. Each take different trade-offs. But more often than not, you might need to choose one over the other. It is compared in the niche the other fails. Like low-level system development, which Rust easily rules. Or maybe dev-ops tooling which Go is easily good at it.
However, there are many overlaps in their use case. Think high-performance web-servers.</description>
    </item>
    <item>
      <title>Moving in Rust is Pure</title>
      <link>https://prma.dev/posts/moving_is_pure/</link>
      <pubDate>Sun, 09 Apr 2023 10:44:00 +0330</pubDate><author>prma.dev@protonmail.com (Perma)</author>
      <guid>https://prma.dev/posts/moving_is_pure/</guid>
      <description>Intro The act of moving arguments within Rust &amp;rsquo;s functions serves as a compelling means to uphold the purity of the function. By embracing this practice, we ensure that the function operates on unique ownership of its inputs, preserving the integrity and immutability of data, which are fundamental tenets of functional programming.
Moving a Variable to a Function in Rust Doesn&amp;rsquo;t Make It Impure So as an introduction, if you don&amp;rsquo;t know Rust .</description>
    </item>
    <item>
      <title>Pure Rust</title>
      <link>https://prma.dev/posts/pure_rust/</link>
      <pubDate>Sat, 25 Mar 2023 22:36:00 +0330</pubDate><author>prma.dev@protonmail.com (Perma)</author>
      <guid>https://prma.dev/posts/pure_rust/</guid>
      <description>Intro If you are not familiar with Functional Programming FP , you are in for a ride. I will try to explain FP in more practical terms.
A definition to work with FP is a declarative way of writing a program that consists mostly of pure functions that operate on and produce immutable data. That was many other unfamiliar words. Let&amp;rsquo;s make it concrete.
Making it more concrete Here is a function in Rust that we will work on:</description>
    </item>
  </channel>
</rss>
